This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-25T12:51:22.229Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
api/
  fetchCatalogInitializers.js
  fetchCatalogItems.js
  fetchCookie.js
  fetchItem.js
entities/
  vinted_item.js
helpers/
  execute_helper.js
services/
  catalog_service.js
  url_service.js
utils/
  config_manager.js
  event_emitter.js
  language.js
  logger.js
  proxies.js
  proxy_manager.js
  request_builder.js
cookieworker.js
main.js
package.json
proxies.txt
ref_main.js

================================================================
Repository Files
================================================================

================
File: api/fetchCatalogInitializers.js
================
import { executeWithDetailedHandling } from "../helpers/execute_helper.js";
import RequestBuilder from "../utils/request_builder.js";
import ConfigurationManager from "../utils/config_manager.js";
import { NotFoundError } from "../helpers/execute_helper.js";

const extension = ConfigurationManager.getAlgorithmSetting.vinted_api_domain_extension

/**
 * Fetch all catalog categories from Vinted
 * @param {Object} params - Parameters for fetching catalog categories
 * @param {string} params.cookie - Cookie for authentication.
 * @returns {Promise<Object>} - Promise resolving to the fetched catalog categories
 */
export async function fetchCatalogInitializer({ cookie }) {
    return await executeWithDetailedHandling(async () => {
        const url = `https://www.vinted.${extension}/api/v2/catalog/initializers`;

        const response = await RequestBuilder.get(url)
                        .setNextProxy()
                        .setCookie(cookie)
                        .send();

        if (!response.success) {
            throw new NotFoundError("Error fetching catalog items.");
        }

        return { data: response.data.dtos };
    });
}

================
File: api/fetchCatalogItems.js
================
import { executeWithDetailedHandling } from "../helpers/execute_helper.js";
import RequestBuilder from "../utils/request_builder.js";
import ConfigurationManager from "../utils/config_manager.js";
import { NotFoundError } from "../helpers/execute_helper.js";

const extension = ConfigurationManager.getAlgorithmSetting.vinted_api_domain_extension

/**
 * Fetch catalog items from Vinted.
 * @param {Object} params - Parameters for fetching catalog items.
 * @param {string} params.cookie - Cookie for authentication.
 * @param {number} [params.per_page=96] - Number of items per page.
 * @param {string} [params.order='newest_first'] - Order of items.
 * @returns {Promise<Object>} - Promise resolving to the fetched catalog items.
 */
export async function fetchCatalogItems({ cookie, per_page = 96, order = 'newest_first' }) {
    return await executeWithDetailedHandling(async () => {
        const url = `https://www.vinted.${extension}/api/v2/catalog/items?per_page=${per_page}&order=${order}`;

        const response = await RequestBuilder.get(url)
                        .setNextProxy()
                        .setCookie(cookie)
                        .send();

        if (!response.success) {
            throw new NotFoundError("Error fetching catalog items.");
        }

        return { items: response.data.items };
    });
}

================
File: api/fetchCookie.js
================
import { executeWithDetailedHandling } from "../helpers/execute_helper.js";
import Logger from "../utils/logger.js";
import ConfigurationManager from "../utils/config_manager.js";
import RequestBuilder from "../utils/request_builder.js";

const settings = ConfigurationManager.getAlgorithmSetting
const extension = settings.vinted_api_domain_extension

/**
 * Fetches the session cookie from the headers of the response to a GET request to the given URL.
 * @param {string} url
 * @returns {Promise<{cookie: string}>}
 * @throws {DetailedExecutionResultError}
 */
export async function fetchCookie() {
    return await executeWithDetailedHandling( async () => {
        const url = `https://www.vinted.${extension}`

        const response = await RequestBuilder.get(url).setNextProxy().send();

        if (response && response.headers['set-cookie']) {

            const cookies = response.headers['set-cookie'];
            const vintedCookie = cookies.find(cookie => cookie.startsWith('access_token_web'));
            if (vintedCookie) {
                const cookie = vintedCookie.split(';')[0];
                Logger.debug(`Fetched cookie: ${cookie}`);

                return { cookie: cookie };
            } else {
                throw new Error("Session cookie not found in the headers.");
            }
        }
        
        throw new Error("No cookies found in the headers.");
    });

}

================
File: api/fetchItem.js
================
import { executeWithDetailedHandling } from "../helpers/execute_helper.js";
import RequestBuilder from "../utils/request_builder.js";   
import ConfigurationManager from "../utils/config_manager.js";
import { NotFoundError, ForbiddenError, RateLimitError } from "../helpers/execute_helper.js";

const extension = ConfigurationManager.getAlgorithmSetting.vinted_api_domain_extension

/**
 * Handle errors during item fetching based on response code.
 * @param {number} code - Response code.
 * @throws {Error} - Corresponding error based on response code.
 */
function handleFetchItemError(code) {
    switch (code) {
        case 404:
            throw new NotFoundError("Item not found.");
        case 403:
            throw new ForbiddenError("Access forbidden.");
        case 429:
            throw new RateLimitError("Rate limit exceeded.");
        default:
            throw new Error("Error fetching item.");
    }
}

/**
 * Fetch a specific item by ID from Vinted.
 * @param {Object} params - Parameters for fetching an item.
 * @param {string} params.cookie - Cookie for authentication.
 * @param {number} params.item_id - ID of the item to fetch.
 * @returns {Promise<Object>} - Promise resolving to the fetched item.
 */
export async function fetchItem({ cookie, item_id }) {
    return await executeWithDetailedHandling(async () => {
        const url = `https://www.vinted.${extension}/api/v2/items/${item_id}`;

        const response = await RequestBuilder.get(url)
                        .setNextProxy()
                        .setCookie(cookie)
                        .send();

        if (!response.success) {
            handleFetchItemError(response.code);
        }

        return { item: response.data.item };
    });
}

================
File: entities/vinted_item.js
================
// Validation functions as standalone utilities
function validateId(value) {
    return (typeof value === 'number' && value > 0) ? value : 0;
  }
  
  function validateNumber(value) {
    return (typeof value === 'number') ? value : 0;
  }
  
  function validateString(value) {
    return (typeof value === 'string') ? value : "N/A";
  }
  
  function validateBoolean(value) {
    return (typeof value === 'boolean') ? value : false;
  }
  
  function validateUrl(value) {
    try {
      new URL(value);
      return value;
    } catch (error) {
      return "N/A";
    }
  }
  
  function parseDate(value) {
    const parsedDate = new Date(value);
    return isNaN(parsedDate.getTime()) ? new Date(0) : parsedDate;
  }
  
  // Classes using external validation functions
  class VintedPhoto {
    constructor(photo) {
      this.id = validateId(photo.id);
      this.imageNo = validateNumber(photo.image_no);
      this.width = validateNumber(photo.width);
      this.height = validateNumber(photo.height);
      this.url = validateUrl(photo.url);
      this.dominantColor = validateString(photo.dominant_color);
      this.fullSizeUrl = validateUrl(photo.full_size_url);
    }
  }

  class VintedUser {
    constructor(userData) {
        this.id = validateId(userData.id);
        this.login = validateString(userData.login);
        this.feedback_reputation = validateNumber(userData.feedback_reputation)
        this.feedback_count = validateNumber(userData.feedback_count)
        this.countryCode = validateString(userData.country_code).toLowerCase();

        this.photo = userData.photo ? new VintedPhoto(userData.photo) : "https://upload.wikimedia.org/wikipedia/commons/9/99/Sample_User_Icon.png"

        this.url = validateUrl(userData.profile_url);
    }
}
  
  class VintedItem {
    constructor(itemData) {
      this.id = validateId(itemData.id);
      this.title = validateString(itemData.title);
      this.url = validateUrl(itemData.url);
      this.brandId = validateId(itemData.brand_id);
      this.sizeId = validateId(itemData.size_id);
      this.statusId = validateId(itemData.status_id);
      this.userId = validateId(itemData.user_id);

      if (itemData.item_attributes?.length > 0 && itemData.item_attributes[0].code === "video_game_platform") {
        this.videoGamePlatformId = validateId(itemData.item_attributes[0].ids?.[0]);
      }

      this.countryId = validateId(itemData.country_id);
      this.catalogId = validateId(itemData.catalog_id);

      this.description = validateString(itemData.description);
      this.size = validateString(itemData.size);
      this.brand = validateString(itemData.brand);
      this.composition = validateString(itemData.composition);
      this.status = validateString(itemData.status);
      this.label = validateString(itemData.label);
      this.currency = validateString(itemData.currency);
      this.priceNumeric = validateNumber(parseFloat(itemData.price_numeric));

      this.updatedAtTs = parseDate(itemData.updated_at_ts);
      this.colorId = validateId(itemData.color1_id);

      // <t:${Math.floor(Date.now() / 1000)}:R>
      this.unixUpdatedAt = Math.floor(this.updatedAtTs.getTime() / 1000); 
      this.unixUpdatedAtString = `<t:${this.unixUpdatedAt}:R>`;
  
      // Create photo objects
      this.photos = itemData.photos ? itemData.photos.map(photo => new VintedPhoto(photo)) : [];

      // Create user object
      this.user = itemData.user ? new VintedUser(itemData.user) : null;

      this.catalogBranchTitle = validateString(itemData.catalog_branch_title);
    }

    getNumericStars() {
      return this.user ? this.user.feedback_reputation : 0;
    }

    getDominantColor() {
      if (this.photos.length === 0) {
        return "#000000";
      }
      return this.photos[0].dominantColor;
    }
  }
  
  export { VintedItem, VintedPhoto };

================
File: helpers/execute_helper.js
================
import Logger from "../utils/logger.js";

const errorStatusMap = {};

/**
 * @typedef {Object} DetailedExecutionResultSuccess
 * @property {boolean} success - Indicates if the operation was successful.
 * @property {number} code - The HTTP status code representing the result.
 * @property {any} result - Contains the primary result data of the successful operation.
 */

/**
 * @typedef {Object} DetailedExecutionResultError
 * @property {boolean} success - Indicates if the operation was successful.
 * @property {number} code - The HTTP status code representing the error.
 * @property {string} error - The error message providing more information.
 */

/**
 * A utility function that wraps an asynchronous function with detailed error handling, including HTTP status codes.
 * @param {Function} asyncFn - The asynchronous function to be executed.
 * @param {...any} params - Arguments to be passed to the asynchronous function.
 * @returns {Promise<DetailedExecutionResultSuccess|DetailedExecutionResultError>} - An object containing the response status, code, and result or error message.
 */
async function executeWithDetailedHandling(asyncFn, ...params) {
    try {
        if (typeof asyncFn !== 'function') {
            throw new TypeError('asyncFn must be a function');
        }

        const result = await asyncFn(...params);

        return { 
            success: true,
            code: 200, // HTTP status for OK
            ...result
        };
    } catch (error) {
        if (!error) {
            throw new Error('An unknown error occurred');
        }

        // Determine the status code based on the type of error
        const statusCode = determineStatusCode(error);
        
        return {
            success: false,
            code: statusCode,
            error: error.message || 'An unknown error occurred'
        };
    }
}

/**
 * Determines the HTTP status code based on the error type using a mapping object.
 */
function determineStatusCode(error) {
    return errorStatusMap[error.name] || 500; // Default to 500 if error name is not mapped
}

/**
 * Factory function for creating custom Error classes with predefined names.
 */
function createCustomError(name, defaultStatusCode) {
    errorStatusMap[name] = defaultStatusCode

    return class extends Error {
        constructor(message) {
            super(message);
            this.name = name;
            this.statusCode = defaultStatusCode;
        }
    };
}

// Custom error classes using the factory function
const NotFoundError = createCustomError("NotFoundError", 404);
const UnauthorizedError = createCustomError("UnauthorizedError", 401);
const ForbiddenError = createCustomError("ForbiddenError", 403);
const BadRequestError = createCustomError("BadRequestError", 400);
const RateLimitError = createCustomError("RateLimitError", 429);
const SaveError = createCustomError("SaveError", 500);

export { 
    executeWithDetailedHandling, 
    NotFoundError,
    UnauthorizedError, 
    ForbiddenError,
    BadRequestError,
    RateLimitError,
    SaveError
};

================
File: services/catalog_service.js
================
import Logger from "../utils/logger.js";
import { fetchCatalogItems } from "../api/fetchCatalogItems.js";
import { fetchItem } from "../api/fetchItem.js";

/**
 * Manage concurrency and fetching logic.
 */
const activePromises = new Set();
let consecutiveErrors = 0;
let rateLimitErrorsPerSecond = 0;

let step = 1;

let lastValidItemsPerSecond = 0;
let validItemsPerSecond = 0;

let lastRequestPerSecond = 0;
let requestPerSecond = 0;

let lastPublishedTime = Date.now();
let idTimeSinceLastPublication = 0;

let minFetchedRange = 0;
let maxFetchedRange = 0;

let currentID = 0;

let concurrency = 0;

function initializeConcurrency( concurrent_requests ) {
    concurrency = concurrent_requests
    computedConcurrency = concurrency;
}

/**
 * Find the highest item ID in the catalog.
 * @param {string} cookie - Cookie for authentication.
 * @returns {Promise<Object>} - Promise resolving to the highest item ID.
 */
async function findHighestID(cookie) {
    const response = await fetchCatalogItems({ cookie });

    if (!response.items) {
        throw new Error("Error fetching catalog items.");
    }

    const maxID = Math.max(...response.items.map(item => parseInt(item.id)));
    return { highestID: maxID };
}

/**
 * Log current status at regular intervals.
 */
setInterval(() => {
    const totalRequests = requestPerSecond + rateLimitErrorsPerSecond;
    const requestSuccessRate = totalRequests ? ((requestPerSecond / totalRequests) * 100).toFixed(2) : 0;

    Logger.debug(`Requests per second: ${requestPerSecond}, Step: ${step}, Consecutive errors: ${consecutiveErrors}, Rate limit errors per second: ${rateLimitErrorsPerSecond}, Valid items per second: ${validItemsPerSecond}`);
    Logger.debug(`Active promises: ${activePromises.size}`);
    Logger.debug(`Current ID: ${currentID}, Last published time: ${lastPublishedTime}, ID time since last publication: ${idTimeSinceLastPublication}`);
    const numberOfItemBetweenRange = maxFetchedRange - minFetchedRange;
    Logger.debug(`minFetchedRange: ${minFetchedRange}, maxFetchedRange: ${maxFetchedRange}, numberOfItemBetweenRange: ${numberOfItemBetweenRange}`);
    Logger.debug(`Request success rate: ${requestSuccessRate}%`);
    Logger.debug(`Concurrency: ${computedConcurrency}`);

    rateLimitErrorsPerSecond = 0;

    lastValidItemsPerSecond = validItemsPerSecond;
    validItemsPerSecond = 0;

    lastRequestPerSecond = requestPerSecond;
    requestPerSecond = 0;

    minFetchedRange = 99999999999;
    maxFetchedRange = 0;
}, 1000);
/**
 * Adjust the concurrency dynamically based on errors and time since last publication.
 */
let computedConcurrency = 2;

setInterval(() => {
    //adjustConcurrency();
    adjustStep();
}, 10);

/**
 * Fetch items until the current item is reached automatically.
 *
 * This function fetches items until the current item is reached automatically.
 * It takes two parameters:
 * - cookie: a string representing the cookie for authentication.
 * - callback: a function to handle fetched items.
 *
 * @param {string} cookie - Cookie for authentication.
 * @param {function} callback - Callback function to handle fetched items.
 */
async function fetchUntilCurrentAutomatic(cookie, callback) {
    // Check if the cookie is provided
    if (!cookie) {
        throw new Error("Cookie is required.");
    }

    // Check if there are more than 3 rate limit errors per second
    /*if (rateLimitErrorsPerSecond > 3) {
        // Delay the function execution by 3 seconds
        await delay(3000);
        return;
    }*/

    while ( activePromises.size < computedConcurrency ) {
        // Calculate the ID for the next item to fetch
        const id = currentID + step;
        currentID = id;

        // Launch the fetch for the calculated ID
        launchFetch(id, cookie, callback);
    }

    // Wait for the first promise in the set to resolve
    await Promise.race(activePromises);

    // Wait for the Promise to resolve
    await Promise.resolve();
}

/**
 * Adjust the fetching step based on time since last publication and consecutive errors.
 *
 * The step is adjusted based on the time since the last publication and the number of consecutive errors.
 * The step is changed gradually to avoid overwhelming the server with requests.
 * The step is also reduced if there are consecutive errors.
 */
// function adjustStep() {
//     // Calculate the time since the last publication
//     const timeSinceLastPublication = Date.now() - lastPublishedTime;

//     // Reduce the step if there are consecutive errors
//     if (consecutiveErrors > 5) {
//         step = -1;
//         return;
//     }

//     // Set the initial step value
//     if (step < 1) {
//         step = 1;
//     }

//     // Adjust the step based on the time since last publication
//     if (timeSinceLastPublication > 20000) {
//         // If it's been longer than 20 seconds since the last publication, double the step and add 10
//         step = Math.min(step * 2 + 10, 20);
//     } else if (timeSinceLastPublication > 10000) {
//         // If it's been longer than 10 seconds since the last publication, double the step and add 5
//         step = 1 
//     }
    
//     // Ensure the step is a whole number
//     step = Math.ceil(step);
// }

function adjustStep() {

    // TRIAL 111111111111111111111111111111111111111111111111111111111
    // Calculate the time since the last publication
    const timeSinceLastPublication = Date.now() - lastPublishedTime;

    // If we have consecutive errors, use a small positive step
    if (consecutiveErrors > 5) {
        step = 1;
        return;
    }

    // Always ensure step is positive
    if (step < 1) {
        step = 1;
    }

    // Adjust step based on time since last publication
    // If we haven't found new items in a while, reduce the step to search more thoroughly
    if (timeSinceLastPublication > 20000) {
        step = 1;  // Reset to small step to search thoroughly
    } else if (timeSinceLastPublication > 10000) {
        step = 1;  // Reset to small step
    } else {
        // If we're finding items regularly, increment step slightly to catch up with new listings
        step = Math.min(step + 1, 5);  // Gradually increase step but cap it at 5
    }

    step = Math.ceil(step);

     // TRIAL 222222222222222222222222222222222222222222222222222222222222
    //  const timeSinceLastPublication = Date.now() - lastPublishedTime;

    //  // If we have consecutive errors, keep searching but more finely
    //  if (consecutiveErrors > 5) {
    //      step = 1;  // Reset to 1 to ensure we don't miss items
    //      return;
    //  }
 
    //  // Keep step small to catch all items
    //  // We'd rather catch all items than skip some
    //  step = Math.min(3, step + 1);  // Never go above 3 to avoid missing items
     
    //  // If we haven't found items in a while, be more thorough
    //  if (timeSinceLastPublication > 10000) {  // 10 seconds
    //      step = 1;  // Reset to check every ID
    //  }
}

/**
 * Launch a fetch operation for a specific item ID.
 *
 * @param {number} id - Item ID to fetch.
 * @param {string} cookie - Cookie for authentication.
 * @param {function} callback - Callback function to handle fetched items.
 * @returns {Promise<void>} - Promise resolving when fetch operation is complete.
 */
async function launchFetch(id, cookie, callback) {
    // Increment the count of requests per second
    requestPerSecond++;

    // Create a promise to fetch and handle the item
    const fetchPromise = fetchAndHandleItemSafe(cookie, id, callback);

    // Add the promise to the set of active promises
    activePromises.add(fetchPromise);

    // Wait for the promise to complete and remove it from the set of active promises
    await fetchPromise.finally(() => {
        activePromises.delete(fetchPromise);
    });
}

/**
 * Fetch and handle a specific item safely.
 *
 * @param {string} cookie - Cookie for authentication.
 * @param {number} itemID - Item ID to fetch.
 * @param {function} callback - Callback function to handle fetched items.
 * @returns {Promise<void>} - Promise resolving when item is handled.
 */
async function fetchAndHandleItemSafe(cookie, itemID, callback) {
    // Fetch the item with the given ID and cookie
    const response = await fetchItem({ cookie, item_id: itemID });

    // If the item was successfully fetched
    if (response.item) {
        // Call the callback function with the fetched item
        callback(response.item);

        // Increment the valid items per second counter
        validItemsPerSecond++;

        // If the item ID is greater than or equal to the ID time since last publication
        if (itemID >= idTimeSinceLastPublication) {
            // Update the ID time since last publication and the last published time
            idTimeSinceLastPublication = itemID;
            lastPublishedTime = new Date(response.item.updated_at_ts).getTime();
        }

        // Reset the consecutive errors counter
        consecutiveErrors -= 1;
        if (consecutiveErrors < 0) {
            consecutiveErrors = 0;
        }

        if (consecutiveErrors > 5) {
            consecutiveErrors = 6;
        }


        // Update the fetched item ID range
        updateFetchedRange(itemID);
    } 
    // If the item was not found (404 error)
    else if (response.code === 404) {
        // Increment the consecutive errors counter
        consecutiveErrors++;
    } 
    // If a rate limit error occurred (429 error)
    else if (response.code === 429) {
        // Increment the rate limit errors per second counter and log the error
        rateLimitErrorsPerSecond++;
        Logger.debug(`Rate limit error: ${rateLimitErrorsPerSecond}`);
    } else {
        consecutiveErrors++;
    }

    // Return a resolved promise
    return Promise.resolve();
}

/**
 * Update the fetched item ID range.
 *
 * @param {number} itemID - The ID of the item to update the range with.
 */
function updateFetchedRange(itemID) {
    /**
     * If the item ID is lower than the current minimum fetched range, update the minimum fetched range.
     */
    if (itemID < minFetchedRange) {
        minFetchedRange = itemID;
    }

    /**
     * If the item ID is higher than the current maximum fetched range, update the maximum fetched range.
     */
    if (itemID > maxFetchedRange) {
        maxFetchedRange = itemID;
    }
}

/**
 * Adjust the concurrency dynamically based on recent errors and successes.
 *
 * The computedConcurrency is adjusted based on the following criteria:
 * - If there have been more than 5 consecutive errors, the computedConcurrency is decreased by 1,
 *   with a minimum of 2.
 * - If there have been no valid items per second for the last 1 second and no valid items per second in
 *   the past, the computedConcurrency is decreased by 1, with a minimum of 2.
 * - If more than 6 seconds have passed since the last valid item was published, the computedConcurrency
 *   is increased by 1, with a maximum of the initial concurrency.
 * - If less than 1 second has passed since the last valid item was published, the computedConcurrency
 *   is decreased by 1, with a minimum of 2.
 */
/*function adjustConcurrency() {
    // Decrease computedConcurrency if there have been more than 5 consecutive errors
    if (consecutiveErrors > 5) {
        if (computedConcurrency > 10) {
            computedConcurrency = 10;
        }
        
        computedConcurrency = Math.max(computedConcurrency - 1, 2);
    } else {
        // Increase computedConcurrency if more than 6 seconds have passed since the last valid item was published
        const timeSinceLastPublication = Date.now() - lastPublishedTime;
        if (timeSinceLastPublication > 5000) {
            computedConcurrency = Math.min(computedConcurrency + 1, concurrency);
        }
        
        // Decrease computedConcurrency if less than 1 second has passed since the last valid item was published
        if (timeSinceLastPublication < 1500) {
            computedConcurrency = Math.max(computedConcurrency - 1, 2);
        }
    }

    // Decrease computedConcurrency if there have been no valid items per second for the last 1 second
    // and no valid items per second in the past
    if (lastValidItemsPerSecond === 0 && validItemsPerSecond === 0) {
        computedConcurrency = Math.max(computedConcurrency - 1, 2);
    }

    // Make sure computedConcurrency is not below 2
    computedConcurrency = Math.max(computedConcurrency, 2);
    // Make sure computedConcurrency is not above the initial concurrency
    computedConcurrency = Math.min(computedConcurrency, concurrency);
}*/


/**
 * Find the highest item ID until successful.
 *
 * @param {string} cookie - Cookie for authentication.
 * @returns {Promise<void>} - Promise resolving when highest ID is found.
 */
async function findHighestIDUntilSuccessful(cookie) {
    // Loop until the highest ID is found
    while (currentID === 0) {
        try {
            // Fetch the highest ID
            const response = await findHighestID(cookie);
            
            // If the highest ID is found, update the current ID and log the value
            if (response.highestID) {
                currentID = response.highestID;
                Logger.info(`Highest ID: ${currentID}`);
            }
        } catch (error) {
            // If an error occurs, log a message and retry
            Logger.error("Error fetching highest ID, retrying...");
        }
    }
}

/**
 * Delay execution for a specified duration.
 * @param {number} ms - Duration in milliseconds.
 * @returns {Promise<void>} - Promise resolving after the delay.
 */
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

const CatalogService = {
    initializeConcurrency,
    fetchUntilCurrentAutomatic,
    findHighestIDUntilSuccessful,
};

export default CatalogService;

================
File: services/url_service.js
================
import { URL } from 'url';
import Logger from '../utils/logger.js';
import ConfigurationManager from '../utils/config_manager.js';
import Fuse from 'fuse.js'; // Import Fuse.js

const blacklisted_countries_codes = ConfigurationManager.getAlgorithmSetting.blacklisted_countries_codes;

function parseVintedSearchParams(url) {
    try {
        const searchParams = {};
        const params = new URL(url).searchParams;
        const paramsKeys = ['search_text', 'order', 'catalog[]', 'brand_ids[]', 'video_game_platform_ids[]', 'size_ids[]', 'price_from', 'price_to', 'status_ids[]', 'material_ids[]', 'color_ids[]'];
        for (const key of paramsKeys) {
            const isMultiple = key.endsWith('[]');
            if (isMultiple) {
                searchParams[key.replace('[]', '')] = params.getAll(key) || null;
            } else {
                searchParams[key] = params.get(key) || null;
            }
        }
        return searchParams;
    } catch (error) {
        Logger.error("Invalid URL provided: ", error.message);
        return null;
    }
}

/**
 * Checks if a Vinted item matches the given search parameters and country codes, using fuzzy search.
 *
 * @param {Object} item - The Vinted item to check.
 * @param {Object} searchParams - The search parameters to match against the item.
 * @param {Array} [countries_codes=[]] - The country codes to check against the item's user country code.
 * @return {boolean} Returns true if the item matches all the search parameters and country codes, false otherwise.
 */
function matchVintedItemToSearchParams(item, searchParams, bannedKeywords, countries_codes = []) {

    // Check blacklisted countries
    if (blacklisted_countries_codes.includes(item.user.countryCode)) {
        return false;
    }

    // Check country codes
    if (countries_codes.length && !countries_codes.includes(item.user.countryCode)) {
        return false;
    }

    const lowerCaseItem = {
        title: item.title.toLowerCase(),
        description: item.description.toLowerCase(),
        brand: item.brand.toLowerCase()
    };

    // make sure the bannedKeywords is an array of lowercase strings
    bannedKeywords = bannedKeywords.map(keyword => keyword.toLowerCase());

    // check for banned keywords in the title and description
    if (bannedKeywords.some(keyword => lowerCaseItem.title.includes(keyword) || lowerCaseItem.description.includes(keyword))) {
        return false;
    }

    // Fuzzy search options
    const fuseOptions = {
        includeScore: true,
        threshold: 0.4,  // Adjust this value for fuzzy tolerance (lower is stricter, higher is more lenient)
        keys: ['title', 'description', 'brand']
    };

    // sanitize the search text
    if (searchParams.search_text && searchParams.search_text.length > 0 && searchParams.search_text !== " ") {
        const searchText = searchParams.search_text.toLowerCase();
        const fuse = new Fuse([lowerCaseItem], fuseOptions);
        const result = fuse.search(searchText);

        // If no result or score is too low, return false
        if (!result.length || result[0].score > 0.4) { // You can adjust the score threshold based on your needs
            return false;
        }
    }

    // Check catalog IDs
    if (searchParams.catalog.length && !searchParams.catalog.some(catalogId => isSubcategory(catalogId, item.catalogId))) {
        return false;
    }

    if (searchParams.price_from && item.priceNumeric < searchParams.price_from) {
        return false;
    }

    if (searchParams.price_to && item.priceNumeric > searchParams.price_to) {
        return false;
    }

    // Check other parameters
    const searchParamsMap = new Map([
        ['brand_ids', 'brandId'],
        ['video_game_platform_ids', 'videoGamePlatformId'],
        ['size_ids', 'sizeId'],
        ['status_ids', 'statusId'],
        ['material_ids', 'material'],
        ['color_ids', 'colorId'],
    ].map(([key, value]) => [key, item[value]]));

    for (const [key, value] of searchParamsMap) {
        if (searchParams[key] !== undefined && searchParams[key] !== null) {
            if (Array.isArray(searchParams[key])) {
                if (searchParams[key].length > 0 && !searchParams[key].includes(value.toString())) {
                    return false;
                }
            } else {
                if (searchParams[key] !== value.toString()) {
                    return false;
                }
            }
        }
    }

    // If all criteria are met, return true
    return true;
}

export function filterItemsByUrl(items, url, bannedKeywords, countries_codes = []) {
    const searchParams = parseVintedSearchParams(url);
    if (!searchParams) return [];

    return items.filter(item => matchVintedItemToSearchParams(item, searchParams, bannedKeywords, countries_codes));
}

================
File: utils/config_manager.js
================
import dotenv from 'dotenv';
import path from 'path';
import fs from 'fs';

dotenv.config();

// Check if .env.local exists and load environment variables from it, overriding the default .env values
const envLocalPath = path.resolve(process.cwd(), '.env.local');
if (fs.existsSync(envLocalPath)) {
    dotenv.config({ path: envLocalPath, override: true });
}

/**
 * Static class to manage application configurations.
 */
class ConfigurationManager {
    /**
     * Retrieves the Discord configuration section from environment variables.
     * @returns {Object} Discord configuration object.
     */
    static getDiscordConfig = {
        client_id: process.env.DISCORD_CLIENT_ID,
        token: process.env.DISCORD_TOKEN,
        role_admin_id: process.env.DISCORD_ROLE_ADMIN_ID,
        guild_id: process.env.DISCORD_GUILD_ID,
        thread_channel_id: process.env.DISCORD_THREAD_CHANNEL_ID,
        command_channel_id: process.env.DISCORD_COMMAND_CHANNEL_ID,
        channel_inactivity_enabled: process.env.ENABLE_CHANNEL_INACTIVITY == 1 ? true : false,
        channel_inactivity_hours: process.env.CHANNEL_INACTIVITY_HOURS,
        channel_inactivity_delete_hours: process.env.CHANNEL_INACTIVITY_DELETE_HOURS,
    }
    
    /**
     * Retrieves the MongoDB configuration section from environment variables.
     * @returns {Object} MongoDB configuration object.
     */
    static getMongoDBConfig = {
        uri: process.env.MONGODB_URI
    }
    
    /**
     * Retrieves the user configuration from environment variables.
     * @returns {Object} User configuration object.
     */
    static getUserConfig = {
        max_private_channels_default: process.env.USER_MAX_PRIVATE_CHANNELS_DEFAULT,
    }

    static getPermissionConfig = {
        allow_user_to_create_private_channels: process.env.ALLOW_USER_TO_CREATE_PRIVATE_CHANNELS == 1 ? true : false
    }

    /**
     * Retrieves the algorithm settings from environment variables.
     * @returns {Object} Algorithm settings object.
     */
    static getAlgorithmSetting = {
        vinted_api_domain_extension: process.env.VINTED_API_DOMAIN_EXTENSION,
        filter_zero_stars_profiles: process.env.ALGORITHM_FILTER_ZERO_STARS_PROFILES == 1 ? true : false,
        concurrent_requests: process.env.ALGORITHM_CONCURRENT_REQUESTS,
        blacklisted_countries_codes : process.env.BLACKLISTED_COUNTRIES_CODES.split(',') || []
    }

    /**
     * Retrieves the rotating proxy configuration from environment variables.
     * @returns {Array} Array of proxy configurations.
     */
    static getProxiesConfig = {
        use_webshare: process.env.USE_WEBSHARE == 1 ? true : false,
        webshare_api_key: process.env.WEBSHARE_API_KEY,
    }

    static getDevMode = process.env.DEV_MODE == 1 ? true : false;
}

export default ConfigurationManager;

================
File: utils/event_emitter.js
================
class EventEmitter {
    constructor() {
        this.events = {};
    }

    // Subscribe to an event
    on(event, listener) {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(listener);
    }

    // Unsubscribe from an event
    off(event, listenerToRemove) {
        if (!this.events[event]) return;

        this.events[event] = this.events[event].filter(listener => listener !== listenerToRemove);
    }

    // Emit an event
    emit(event, payload = null) {
        if (!this.events[event]) return;

        this.events[event].forEach(listener => listener(payload));
    }
}

export default EventEmitter;

================
File: utils/language.js
================
import fs from 'fs';
import path from 'path';
import Logger from './logger.js';

const __dirname = path.resolve();

/**
 * Don't dare to touch this file or you will be cursed by the gods of localization.
 */
class LanguageService {
    static localesDir = path.join(__dirname, 'locales'); // Adjust path as needed
    static languages = {};
    static fallbackLanguage = 'en-GB';

    static initialize() {
        const files = fs.readdirSync(this.localesDir);
        files.forEach(file => {
            const filePath = path.join(this.localesDir, file);
            const lang = path.basename(file, '.json');
            Logger.info(`Loading language file for ${lang}`);
            this.languages[lang] = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
        });
    }

    static getText(lang, key) {
        // Check if the language exists
        if (!this.languages[lang]) {
            console.warn(`Language ${lang} not found, falling back to ${this.fallbackLanguage}`);
            lang = this.fallbackLanguage;
        }

        // Check if the key exists in the specified language
        if (this.languages[lang] && this.languages[lang][key]) {
            return this.languages[lang][key];
        }

        // Fall back to the default language if the key is not found in the specified language
        if (lang !== this.fallbackLanguage && this.languages[this.fallbackLanguage] && this.languages[this.fallbackLanguage][key]) {
            return this.languages[this.fallbackLanguage][key];
        }

        return `Missing translation for "${key}"`;
    }
}

// Initialize the languages when the module is loaded
LanguageService.initialize();

export default LanguageService;

================
File: utils/logger.js
================
import fs from 'fs';
import path from 'path';
import chalk from 'chalk';

import ConfigurationManager from './config_manager.js';

const devMode = ConfigurationManager.getDevMode

class Logger {
    static logFilePath = path.join(process.cwd(), 'app.log');

    static initialize() {
        if (!fs.existsSync(Logger.logFilePath)) {
            fs.writeFileSync(Logger.logFilePath, '');
        }
    }

    static info(message) {
        Logger.log('INFO', message, chalk.green);
    }

    static warn(message) {
        Logger.log('WARN', message, chalk.yellow, true);
    }

    static error(message) {
        Logger.log('ERROR', message, chalk.red, true);  // Pass `true` to indicate this is an error
    }

    static debug(message) {
        if (!devMode) {
            return;
        }

        Logger.log('DEBUG', message, chalk.magenta);
    }

    static log(level, message, colorFn, includeSource = false) {

        const timestamp = new Date().toISOString();
        const formattedLevel = colorFn(`[${level}]`);
        let logMessage = `${timestamp} ${formattedLevel}: ${message}`;

        if (includeSource) {
            // get stack of the message
            const source = Logger.getCallSource();
            logMessage += ` [${source}]`;
        }

        console.log(logMessage);
        fs.appendFileSync(Logger.logFilePath, `${logMessage}\n`);
    }

    static getCallSource() {
        const stack = new Error().stack; // Create an Error and capture the stack
        const stackLines = stack.split('\n');
        let callerLine = stackLines[4]; // Get the relevant caller line from stack; Adjust this number based on where this method is within your stack trace

        if (callerLine) {
            callerLine = callerLine.replace(/^\s+at\s+/g, ''); // Clean up the stack trace line
            return callerLine;
        }

        return 'Unknown caller';
    }
}

Logger.initialize(); // Ensure log file is initialized at startup

export default Logger;

================
File: utils/proxies.js
================
export class Proxy {
    constructor(ip, port, username, password) {
        this.ip = ip;
        this.port = port;
        this.username = username;
        this.password = password;
        this.method = "socks"
    }

    getProxyString() {
        return `${this.method}://${this.username}:${this.password}@${this.ip}:${this.port}`
    }

}

export async function listProxies(apiKey, timeout = 10000) {
    if (!apiKey) {
        throw new Error("API key is required.");
    }

    const baseUrl = 'https://proxy.webshare.io/api/v2/proxy/list/';
    let allProxies = [];
    let page = 1;
    let totalPages = 1;

    while (page <= totalPages) {
        const url = new URL(baseUrl);
        url.searchParams.append('mode', 'direct');
        url.searchParams.append('page_size', '100');
        url.searchParams.append('page', page);

        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);

            const req = await fetch(url.href, {
                method: "GET",
                headers: {
                    Authorization: "Token " + apiKey,
                },
                signal: controller.signal
            });

            clearTimeout(timeoutId);

            if (!req.ok) {
                throw new Error(`HTTP error! status: ${req.status}`);
            }

            const res = await req.json();

            const proxies = res.results.map((proxy) =>
                new Proxy(proxy.proxy_address, proxy.port, proxy.username, proxy.password)
            );

            allProxies = allProxies.concat(proxies);

            totalPages = Math.ceil(res.count / 100);
            page++;
        } catch (error) {
            if (error.name === 'AbortError') {
                throw new Error('Request timed out');
            }
            throw error;
        }
    }

    return allProxies;
}

================
File: utils/proxy_manager.js
================
import { SocksProxyAgent } from 'socks-proxy-agent';
import Logger from './logger.js';
import { listProxies, Proxy } from './proxies.js';
import ConfigurationManager from './config_manager.js';
import fs from 'fs';

const proxy_settings = ConfigurationManager.getProxiesConfig

/**
 * Static class for managing proxy settings and making HTTP requests with SOCKS authentication.
 */
class ProxyManager {
    static proxyConfig = null;
    static proxies = [];
    static proxiesLoaded = false;
    static currentProxyIndex = 0;
    static proxiesOnCooldown = [];

    static async init(maxRetries = 3, retryDelay = 5000) {
        for (let attempt = 0; attempt < maxRetries; attempt++) {
            try {
                if (proxy_settings.use_webshare) {
                    this.proxies = await listProxies(proxy_settings.webshare_api_key);
                    Logger.info(`Loaded ${this.proxies.length} proxies from Webshare.`);
                } else {
                    // Read the proxy file
                    const proxyFile = fs.readFileSync('proxies.txt', 'utf8');
                    const proxyLines = proxyFile.split('\n');

                    // Parse the proxy lines
                    for (const line of proxyLines) {
                        const parts = line.split(':');
                        if (parts.length === 4) {
                            const proxy = new Proxy(parts[0], parts[1], parts[2], parts[3]);
                            this.proxies.push(proxy);
                        }
                    }
                    Logger.info(`Loaded ${this.proxies.length} proxies from file.`);
                }
                return;
            } catch (error) {
                Logger.error(`Attempt ${attempt + 1} failed to initialize proxies: ${error.message}`);
                if (attempt === maxRetries - 1) {
                    Logger.error('Failed to initialize proxies after maximum retries');
                    throw error;
                }
                await new Promise(resolve => setTimeout(resolve, retryDelay));
            }
        }
    }

    /**
     * Clears the proxy configuration.
     */
    static clearProxy() {
        this.proxyConfig = null;
    }

    /**
     * Retrieves the current proxy agent if a proxy is configured.
     * @returns {SocksProxyAgent|undefined} The proxy agent or undefined if no proxy is set.
     */
    static getNewProxy() {

        if (this.proxies.length > 0) {
            this.currentProxyIndex = (this.currentProxyIndex + 1) % this.proxies.length;

            const proxy = this.proxies[this.currentProxyIndex];

            return proxy
        }
        
        Logger.error('No proxies available.');

        return undefined;
    }

    /** 
     * Get New Proxy Socks Agent
     * @param {Proxy} proxy - The proxy to get the agent for
     * @returns {SocksProxyAgent} - The proxy agent
     */
    static getProxyAgent(proxy) {
        return new SocksProxyAgent(proxy.getProxyString());
    }
    

    /** 
     * Remove invalid proxies from the list
     * @param {Proxy} proxy - The proxy to remove
     * @returns {void}
     */
    static removeProxy(proxy) {
        this.proxies = this.proxies.filter(p => p !== proxy);
    }


    static removeTemporarlyInvalidProxy(proxy, timeout = 60000) {
        this.proxiesOnCooldown.push(proxy);
        this.proxies = this.proxies.filter(p => p !== proxy);

        setTimeout(() => {
            this.proxies.push(proxy);
            this.proxiesOnCooldown = this.proxiesOnCooldown.filter(p => p !== proxy);
        }, timeout);
    }
}

export default ProxyManager;

================
File: utils/request_builder.js
================
import axios from 'axios';
import ProxyManager from './proxy_manager.js';
import { getRandom } from 'random-useragent';
import Logger from './logger.js';
import ConfigurationManager from './config_manager.js';

const algorithm_settings = ConfigurationManager.getAlgorithmSetting
const vinted_api_domain_extension = algorithm_settings.vinted_api_domain_extension;

const BASE_HEADERS = {
    'Accept': 'application/json, text/plain, */*',
    'Accept-Encoding': 'gzip, deflate, br',
    'Accept-Language': 'fr=FR, en-US',
    'Sec-Fetch-Dest': 'empty',
    'Sec-Fetch-Mode': 'cors',
    'Sec-Fetch-Site': 'same-origin',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive',
    'Origin': `https://www.vinted.${vinted_api_domain_extension}`,
    'DNT': '1',
    'Upgrade-Insecure-Requests': '1',
    'Sec-Ch-Ua-Mobile': '?0',
    'TE': 'trailers',
    'Sec-Ch-Ua-Mobile': '?1',
    'Priority': 'u=0, i',
};

class RequestBuilder {
    constructor(url, method = 'GET') {
        this.url = url;
        this.method = method.toUpperCase(); // default is GET, but can be POST, PUT, DELETE, etc.
        this.headers = { ...BASE_HEADERS };
        this.proxy = null;
        this.timeout = 5000; // default timeout in milliseconds
        this.params = {};
        this.data = null; // used for POST/PUT requests
        
        return this; // return the instance to allow chaining
    }

    // Set custom headers
    setHeaders(headers) {
        this.headers = { ...this.headers, ...headers };
        return this; // return the instance to allow chaining
    }

    // Set proxy from proxy manager
    setProxy(proxy) {
        proxy = ProxyManager.getProxyAgent(proxy);

        this.proxy = proxy;
        return this;
    }

    // Set Next Proxy
    setNextProxy() {
        const proxy = ProxyManager.getNewProxy();
        this.setProxy(proxy);
        return this
    }

    // Set request timeout
    setTimeout(timeout) {
        this.timeout = timeout;
        return this;
    }

    // Add URL parameters (query parameters for GET/DELETE, or params for other methods)
    setParams(params) {
        this.params = { ...this.params, ...params };
        return this;
    }

    // Set request body data for POST/PUT/PATCH/DELETE requests
    setData(data) {
        this.data = data;
        return this;
    }

    // Change the HTTP method dynamically
    setMethod(method) {
        this.method = method.toUpperCase();
        return this;
    }

    setCookie(cookie) {
        this.headers['Cookie'] = cookie;
        return this;
    }

    // Build and send the request
    async send() {

        // Get a random user-agent
        const userAgent = getRandom( (ua) => {
            return parseFloat(ua.browserVersion) >= 50;
        });

        Logger.debug(`Sending request to ${this.url} with user-agent: ${userAgent}`);

        this.headers['User-Agent'] = userAgent;

        const config = {
            method: this.method,
            url: this.url,
            headers: this.headers,
            agent: this.proxy,
            timeout: this.timeout,
            params: this.params,
            httpsAgent: this.proxy,
            httpAgent: this.proxy,
        };

        // If the method is POST, PUT, PATCH, DELETE, and body data exists, add it to the request
        if (['POST', 'PUT', 'PATCH', 'DELETE'].includes(this.method) && this.data) {
            config.data = this.data;
        }

        try {
            const response = await axios(config);
            response.success = response.status >= 200 && response.status < 300;
            return response
        } catch (error) {
            // if response is a 404 it's not an error
            if (error.response && error.response.status === 404) {
                throw new Error('Not found');
            }

            Logger.debug(`Error sending request to ${this.url}, status: ${error.response.status}`);
            this.proxy && ProxyManager.removeTemporarlyInvalidProxy(this.proxy);
            throw error;
        }
    }
}

RequestBuilder.get = (url) => new RequestBuilder(url, 'GET');
RequestBuilder.post = (url) => new RequestBuilder(url, 'POST');
RequestBuilder.put = (url) => new RequestBuilder(url, 'PUT');

export default RequestBuilder;

================
File: cookieworker.js
================
import { parentPort } from 'worker_threads';
import { fetchCookie } from "./api/fetchCookie.js";
import Logger from "./utils/logger.js";
import ProxyManager from "./utils/proxy_manager.js";

const getCookie = async () => {
    const result = await fetchCookie();
    return result.cookie;
};

const refreshCookie = async () => {
    try {
        Logger.info('Worker: Starting cookie refresh...');
        
        // Initialize proxies in worker if not already initialized
        if (ProxyManager.proxies.length === 0) {
            Logger.info('Worker: Initializing proxies...');
            await ProxyManager.init();
            Logger.info('Worker: Proxies initialized successfully');
        }

        let found = false;
        while (!found) {
            try {
                Logger.info('Worker: Attempting to fetch cookie...');
                const cookie = await getCookie();
                if (cookie) {
                    found = true;
                    Logger.info('Worker: Successfully got cookie');
                    parentPort.postMessage({ type: 'cookie', cookie: cookie });
                    return cookie;
                }
            } catch (error) {
                Logger.debug('Worker: Error fetching cookie, retrying...');
                await new Promise(resolve => setTimeout(resolve, 200));
            }
        }
    } catch (error) {
        Logger.error(`Worker: Error in refresh: ${error.message}`);
    }
};

// Initial cookie fetch
Logger.info('Worker: Starting initial cookie fetch...');
refreshCookie();

// Refresh cookie every minute
setInterval(refreshCookie, 60000);

// Handle any uncaught errors
process.on('uncaughtException', (error) => {
    Logger.error(`Worker uncaught exception: ${error.message}`);
});

================
File: main.js
================
import ProxyManager from "./utils/proxy_manager.js";
import { VintedItem } from "./entities/vinted_item.js";
import ConfigurationManager from "./utils/config_manager.js";
import Logger from "./utils/logger.js";
import CatalogService from "./services/catalog_service.js";
import { Worker } from 'worker_threads';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

let cookie = null;

Logger.info('Starting Vinted Bot');

try {
    Logger.info('Main: Initializing proxies...');
    await ProxyManager.init();
    Logger.info('Main: Proxies initialized successfully');
} catch (error) {
    Logger.error(`Main: Failed to initialize proxies: ${error.message}`);
}


const algorithmSettings = ConfigurationManager.getAlgorithmSetting;
CatalogService.initializeConcurrency(algorithmSettings.concurrent_requests);

// Create a promise that will resolve with our first cookie
const cookiePromise = new Promise((resolve) => {
    Logger.info('Starting cookie worker...');
    
    const cookieWorker = new Worker(join(__dirname, 'cookieworker.js'), {
        type: 'module'
    });

    cookieWorker.on('message', (message) => {
        Logger.info(`Main: Received message from worker: ${JSON.stringify(message)}`);
        if (message.type === 'cookie' && message.cookie) {
            cookie = message.cookie;
            Logger.info('Main: Got valid cookie from worker');
            resolve(cookie);
        }
    });
    
    cookieWorker.on('error', (error) => {
        Logger.error(`Cookie worker error: ${error.message}`);
    });

    cookieWorker.on('exit', (code) => {
        if (code !== 0) {
            Logger.error(`Worker stopped with exit code ${code}`);
        }
    });
});

// Function to format price
const formatPrice = (price, currency) => {
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: currency
    }).format(price);
};

// Function to format time difference
const formatTimeDifference = (timestamp) => {
    const now = Date.now();
    const diffInSeconds = Math.floor((now - timestamp * 1000) / 1000);

    if (diffInSeconds < 60) {
        return `${diffInSeconds}s ago`;
    } else if (diffInSeconds < 3600) {
        const minutes = Math.floor(diffInSeconds / 60);
        return `${minutes}m ago`;
    } else if (diffInSeconds < 86400) {
        const hours = Math.floor(diffInSeconds / 3600);
        return `${hours}h ago`;
    } else {
        const days = Math.floor(diffInSeconds / 86400);
        return `${days}d ago`;
    }
};

// Function to format absolute time
const formatAbsoluteTime = (timestamp) => {
    return new Date(timestamp * 1000).toLocaleString();
};

const monitorItems = async () => {
    try {
        Logger.info('Main: Waiting for initial cookie...');
        await cookiePromise;
        Logger.info('Main: Got initial cookie, starting monitor...');

    const handleItem = async (rawItem) => {
        const item = new VintedItem(rawItem);

        if (item.getNumericStars() === 0 && algorithmSettings.filter_zero_stars_profiles) {
            return;
        }

        // Format both relative and absolute time
        const relativeTime = formatTimeDifference(item.unixUpdatedAt);
        const absoluteTime = formatAbsoluteTime(item.unixUpdatedAt);

        // Create a formatted string with item details
        const itemDetails = [
            `\x1b[36m${item.title}\x1b[0m`,  // Cyan color for title
            `Posted: \x1b[33m${relativeTime}\x1b[0m (\x1b[90m${absoluteTime}\x1b[0m)`,
            `ID: \x1b[90m${item.id}\x1b[0m`,  // Gray color for ID
        ].join(' | ');

        console.log(''.repeat(process.stdout.columns));
        console.log(itemDetails);
    };

    (async () => {
        await CatalogService.findHighestIDUntilSuccessful(cookie);
        Logger.info('Starting to monitor items...');

        while (true) {
            try {
                await CatalogService.fetchUntilCurrentAutomatic(cookie, handleItem);
            } catch (error) {
                console.error('Error fetching items:', error);
                // Add a small delay before retrying
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }
    })();
} catch (error) {
    Logger.error(`Monitor error: ${error.message}`);
}
};

monitorItems().catch(error => {
    Logger.error(`Monitor error: ${error.message}`);
});

================
File: package.json
================
{
  "dependencies": {
    "axios": "^1.6.8",
    "chalk": "^5.3.0",
    "discord.js": "^14.15.2",
    "dotenv": "^16.4.5",
    "fuse.js": "^7.0.0",
    "https-proxy-agent": "^7.0.5",
    "js-yaml": "^4.1.0",
    "mongoose": "^8.3.4",
    "random-useragent": "^0.5.0",
    "socks-proxy-agent": "^8.0.3"
  },
  "type": "module",
  "name": "vinted-no-delay",
  "version": "1.0.0",
  "main": "main.js",
  "scripts": {
    "start": "node --max-old-space-size=4096 main.js",
    "dev": "nodemon --max-old-space-size=4096 main.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "description": "",
  "devDependencies": {
    "nodemon": "^3.1.7"
  }
}

================
File: proxies.txt
================
gate.smartproxy.com:7000:spfim00qzo:O2YLaf8+o8tdtsi3oZ

================
File: ref_main.js
================
import ProxyManager from "./utils/proxy_manager.js";
import { VintedItem } from "./entities/vinted_item.js";
import ConfigurationManager from "./utils/config_manager.js";
import { fetchCookie } from "./api/fetchCookie.js";
import Logger from "./utils/logger.js";
import CatalogService from "./services/catalog_service.js";

var cookie = null;

try {
    await ProxyManager.init();
} catch (error) {
    Logger.error(`Failed to initialize proxies: ${error.message}`);
    Logger.info('Continuing without proxies...');
}

const algorithmSettings = ConfigurationManager.getAlgorithmSetting;
CatalogService.initializeConcurrency(algorithmSettings.concurrent_requests);

const getCookie = async () => {
    const c = await fetchCookie();
    return c.cookie;
};

const refreshCookie = async () => {
    let found = false;
    while (!found) {
        try {
            const cookie = await getCookie();
            if (cookie) {
                found = true;
                Logger.info('Fetched cookie from Vinted');
                return cookie;
            }
        } catch (error) {
            Logger.debug('Error fetching cookie');
            await new Promise(resolve => setTimeout(resolve, 200));
        }
    }
};

Logger.info('Starting Vinted Bot');
Logger.info('Fetching cookie from Vinted');

cookie = await refreshCookie();

setInterval(async () => {
    try {
        cookie = await refreshCookie();
    } catch (error) {
        Logger.debug('Error refreshing cookie');
    }
}, 60000);

// Function to format price
const formatPrice = (price, currency) => {
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: currency
    }).format(price);
};

// Function to format time difference
const formatTimeDifference = (timestamp) => {
    const now = Date.now();
    const diffInSeconds = Math.floor((now - timestamp * 1000) / 1000);

    if (diffInSeconds < 60) {
        return `${diffInSeconds}s ago`;
    } else if (diffInSeconds < 3600) {
        const minutes = Math.floor(diffInSeconds / 60);
        return `${minutes}m ago`;
    } else if (diffInSeconds < 86400) {
        const hours = Math.floor(diffInSeconds / 3600);
        return `${hours}h ago`;
    } else {
        const days = Math.floor(diffInSeconds / 86400);
        return `${days}d ago`;
    }
};

// Function to format absolute time
const formatAbsoluteTime = (timestamp) => {
    return new Date(timestamp * 1000).toLocaleString();
};

const monitorItems = () => {
    const handleItem = async (rawItem) => {
        const item = new VintedItem(rawItem);

        if (item.getNumericStars() === 0 && algorithmSettings.filter_zero_stars_profiles) {
            return;
        }

        // Format both relative and absolute time
        const relativeTime = formatTimeDifference(item.unixUpdatedAt);
        const absoluteTime = formatAbsoluteTime(item.unixUpdatedAt);

        // Create a formatted string with item details
        const itemDetails = [
            `\x1b[36m${item.title}\x1b[0m`,  // Cyan color for title
            // `Price: \x1b[33m${formatPrice(item.priceNumeric, item.currency)}\x1b[0m`,  // Yellow color for price
            // `Brand: \x1b[35m${item.brand || 'No Brand'}\x1b[0m`,  // Magenta color for brand
            // `Size: ${item.size || 'No Size'}`,
            // `Status: ${item.status}`,
            // `Seller: \x1b[32m${item.user.login}\x1b[0m (${item.user.countryCode.toUpperCase()})`,  // Green color for seller name
            // `Rating: ${''.repeat(Math.round(item.getNumericStars()))}`,
            `Posted: \x1b[33m${relativeTime}\x1b[0m (\x1b[90m${absoluteTime}\x1b[0m)`, // Yellow for relative time, gray for absolute time
           `ID: \x1b[90m${item.id}\x1b[0m`,  // Gray color for ID
            // `URL: \x1b[34m${item.url}\x1b[0m`  // Blue color for URL
        ].join(' | ');

        console.log(''.repeat(process.stdout.columns)); // Separator line
        console.log(itemDetails);
    };

    (async () => {
        await CatalogService.findHighestIDUntilSuccessful(cookie);
        Logger.info('Starting to monitor items...');

        while (true) {
            try {
                await CatalogService.fetchUntilCurrentAutomatic(cookie, handleItem);
            } catch (error) {
                console.error('Error fetching items:', error);
            }
        }
    })();
};

monitorItems();
